- 小程序的导航栏文字在安卓手机中居左，ios中居中

- 背景颜色从中间向两边渐变  
  虽然`linear-gradient()`没有提供从两边向中间又或者从中间向两边的方位关键词来实现渐变，但可以通过设置对称的颜色值来实现这点
  ```css
  // 中间向两边
  background-image: linear-gradient(to right, red 0% orange 50% red 100%);
  ```

- 小程序的多行文字省略，需要将盒子特地设置为`display: -webkit-box`  
  ```css
  .box {
    display: -webkit-box;
    word-break: break-all;
    -webkit-box-orient: vertical;
    -webkit-line-clamp: 3;
    text-overflow: ellipsis;
    overflow: hidden;
    /* 
      一般来说需要给个固定高度，且为了配合-webkit-line-clamp 设定的行数，高度应该设定为 行高 * 行数 
    */
    line-height: 1.3em;
    height: calc(1.3rem * 3);
  }
  ```

- 小程序组件上不能随意添加自定义名称的属性，否则不会被正确的挂载上去，如果想通过特定属性来应用样式是不可行的，自定义的属性必须以`data-`开头
  ```
  如果想通过 tag-type="1" 这个标识，通过属性选择器 [tag-type="1"] 来应用样式是不可行的
  必须 data-tag-type="1" 
  ```

- 轮播图两边小中间大的效果需要通过动态地改变样式实现  
  利用`bindchange`事件对象上带的参数`e.detail.current`来判断当前项是否为显示的项
  ```js
  Page({
    data: {
      currentSwiperItem: 0
    },
    SwiperChange(e) {
      this.setData({
        currentSwiperItem: e.detail.current,
      })
    },
  })

  // 在对应的 wxml 中判断当前项的 index 是否等于 currentSwiperItem，然后应用对应样式
  ```
  
- 小程序使用云开发时，对应的APPID应该已经**开通云开发环境**才行  
  小程序的云函数需要选择环境来使用：右键云函数根目录，**选择环境**  
  小程序的**云函数在本地编写之后需要上传到云环境中**才能使用，右键对应云函数目录上传（任何已经部署到云环境中的云函数的文件夹标识都是一朵云）  
  （小程序示例中还需要将 /miniprogram/config.js 中的 envId 改为当前的 云环境ID）  
  > https://github.com/wechat-miniprogram/miniprogram-demo/blob/master/miniprogram/page/cloud/README.md

- worker 的使用   
  小程序中可以创建一个 worker 线程来处理一些任务（异步请求、耗时的计算等），避免占用主线程资源导致页面产生卡顿      
  使用的基本流程：  
  - 在 app.json 中指定 workers 代码入口目录（目录下代码会被打包成一个文件）
    ```json
    {
      workers: "workers"
    }
    ```
  - 创建 worker 以启用线程，需要指定线程入口文件（需要为一个不以`/`开头的绝对路径）
    ```js
    const worker = wx.createWorker("workers/fib/index.js");
    ```
  - 主线程和 worker 通信
    ```js
    worker.postMessage({}); // 发送信息
    worker.onMessage(function(res) {}); // 接收信息
    ```
  注意事项：  
  - worker 最大并发数量限制为 1 个，再创建时需要先通过`worker.terminate()`结束之前那个 worker
  - workers 内的代码只能 require 到 workers 目录下的路径
  - workers 不能调用 wx 系列的 API 
  - workers 目录下只能放 JS 文件
  - 在哪里需要使用到 worker 就需要在哪里创建一个 worker ，而在对于 worker 当前入口文件的执行上下文中可以直接使用 worker 而不需要创建（注意这个文件里的 worker 名称就为“worker”，用别的只会告诉你未定义）   
    *可以通过在 app 实例上挂载 worker 来让全局使用同一个 worker，但这只适用于 worker 只有一个入口文件的情况* 
  - worker 还有一个实验性 worker ，在 ios 下其 JS 运行效率会比普通的快10倍    
    需要通过参数项配置：  
    ```js
    wx.createWorker('path/to/entry.js', {
      useExperimentalWorker: true
    })
    ```
    由于在极小概率下实验性 worker 会在资源紧张的情况下被系统回收，可通过`worker.onProcessKilled()`监听，被销毁后再创建一个   
    所以对于普通 worker 和 实验性 worker 有如下最佳实践创建方式的差异
    ```js
    // 普通
    wx.createWorker('path/to/entry.js');   

    // 实验性
    function createNewWorker(scriptPath) {
      const worker = wx.createWorker('path/to/entry.js', {
        useExperimentalWorker: true
      });
      worker.onProcessKilled(() => {
        createNewWorker(scriptPath);
      });

      return worker;
    }
    ```